//  You have to sign each API request by passing several generated keys and tokens in an authorization header
//  oauth_consumer_key - APIKey from Config struct
//  oauth_nonce - is a unique token your application should generate for each unique request
//  The value for this request was generated by base64 encoding 32 bytes of random data, and stripping
//  out all non-word characters
//  oauth_signature_method - HMAC-SHA1
//  oauth_timestamp - parameter indicates when the request was created.
//  This value should be the number of seconds since the Unix epoch at the point the request is generated

package twitter_ads

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"
)

const (
	apiURL     = "https://ads-api.twitter.com/"
	apiVersion = "11"
)

type SignatureCreator interface {
	CreateAuthorizationString(s SignatureRequest) string
}

type API struct {
	*Config
	url        string
	version    string
	auth       SignatureCreator
	httpClient *http.Client
}

func NewAPIClient(conf *Config) (*API, error) {
	if err := conf.Validate(); err != nil {
		return nil, fmt.Errorf("not enough fields: %w", err)
	}

	return &API{
		Config:     conf,
		url:        apiURL,
		version:    apiVersion,
		auth:       NewAuthHandler(),
		httpClient: newHTTPClient(),
	}, nil
}

func (c *API) WithAPIVersion(version string) *API {
	c.version = version

	return c
}

func (c *API) WithAPIURL(url string) *API {
	c.url = url

	return c
}

func (c *API) GetAccountsInfo() ([]byte, error) {
	q := url.Values{}
	const accounts = "/accounts"

	return c.makeRequest(accounts, "", http.MethodGet, q)
}

func (c *API) GetCampaignInfo(accountID, campaignID string) (*CampaignInfo, error) {
	sendURL := fmt.Sprintf("/accounts/%s/campaigns/%s", accountID, campaignID)

	body, err := c.makeRequest(sendURL, "", http.MethodGet, url.Values{})
	if err != nil {
		return nil, fmt.Errorf("can't get campaign info from twitter api: %w", err)
	}

	campaign := CampaignInfo{}

	if err = json.Unmarshal(body, &campaign); err != nil {
		return nil, fmt.Errorf("can't get campaign info from twitter api: %w", err)
	}

	return &campaign, nil
}

func (c *API) GetSpendStats(accountID, entityID, startTime, endTime string) (*SpendStats, error) {
	entity := "CAMPAIGN"

	q := url.Values{}
	q.Add("start_time", startTime)
	q.Add("end_time", endTime)
	q.Add("entity", entity)
	q.Add("entity_ids", entityID)
	q.Add("granularity", "TOTAL")
	q.Add("placement", "ALL_ON_TWITTER")
	q.Add("metric_groups", "BILLING")

	sendURL := fmt.Sprintf("/stats/accounts/%s", accountID)

	body, err := c.makeRequest(sendURL, "", http.MethodGet, q)
	if err != nil {
		return nil, fmt.Errorf("can't get spend stats from twitter api: %w", err)
	}

	stats := SpendStats{}

	if err = json.Unmarshal(body, &stats); err != nil {
		return nil, fmt.Errorf("can't deserialize spend stats response: %w", err)
	}

	return &stats, nil
}

func (c *API) GetActiveEntities(accountID, startTime, endTime string) (*ActiveEntitiesResponse, error) {
	entity := "CAMPAIGN"

	q := url.Values{}
	q.Add("start_time", startTime)
	q.Add("end_time", endTime)
	q.Add("entity", entity)
	sendURL := fmt.Sprintf("/stats/accounts/%s/active_entities", accountID)

	body, err := c.makeRequest(sendURL, "", http.MethodGet, q)
	if err != nil {
		return nil, fmt.Errorf("can't get active entities from twitter api: %w", err)
	}

	activeEntities := ActiveEntitiesResponse{}

	err = json.Unmarshal(body, &activeEntities)
	if err != nil {
		return nil, fmt.Errorf("can't serialize active entities response: %w", err)
	}

	return &activeEntities, nil
}

const authorizationHeader = "Authorization"

type SignatureRequest struct {
	method       string
	body         string
	url          string
	params       url.Values
	key          string
	token        string
	secret       string
	accessSecret string
}

func (c *API) makeRequest(baseURL, requestBody, method string, q url.Values) ([]byte, error) {
	requestURL := fmt.Sprintf("%s%s%s", c.url, c.version, baseURL)
	urlWithParams := requestURL
	if len(q) != 0 {
		urlWithParams = requestURL + "?" + q.Encode()
	}

	req, err := http.NewRequest(method, urlWithParams, nil)
	if err != nil {
		return nil, fmt.Errorf("can't create new http request: %w", err)
	}

	signRequest := SignatureRequest{
		method:       req.Method,
		body:         requestBody,
		url:          requestURL,
		params:       q,
		key:          c.APIKey,
		token:        c.AccessToken,
		secret:       c.APISecret,
		accessSecret: c.AccessSecret,
	}

	req.Header.Set(authorizationHeader, c.auth.CreateAuthorizationString(signRequest))

	res, err := c.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("can't make http request: %w", err)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, fmt.Errorf("can't read response body: %w", err)
	}

	return body, nil
}

func newHTTPClient() *http.Client {
	t := http.DefaultTransport.(*http.Transport).Clone()
	t.MaxIdleConns = 100
	t.MaxConnsPerHost = 100
	t.MaxIdleConnsPerHost = 100

	c := &http.Client{
		Timeout:   10 * time.Second,
		Transport: t,
	}

	return c
}
